<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>浏览器端面试四大问：浏览器的缓存，浏览器渲染原理，存储，跨域（个人笔记）</title>
<meta charset=utf-8><meta name=description content="Ladder@浏览器的缓存
https://www.cnblogs.com/lyzg/p/5125934.html
浏览器的缓存，缓存的一般是一些内存比较小的静态的资源。缓存的主要位置是:
Service Work
Memory Cache:浏览器自带，内存较小，速度较快
Disk Cache：存在本地，内存较大，加载速度较慢
Push Cache 缓存策略：
主要分为两种强缓存和协商缓存
强缓存 强缓存是利用Expires 或 cache control 这两个http response header 实现；
强缓存是浏览器现在缓存中查找是否有该资源。命中时状态码为200
Expires:是老浏览器使用的，是一串带有固定时间的字符。他表示的是这个资源缓存的过期时间。
它的工作原理是：
在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的Expires的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，就把exprice和当前的时间作比较，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。
它的缺点：因为它是和本地时间作比较的，当你的本地时间不准时它很有可能有误差。所以为了解决这个问题就有了cache control;
cache control: 是一串数字，以秒为单位，代表的是过多久时间过期。
它的工作原理是：
在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的cache control的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，他会根据第一次请求的时间和cache control的时间计算一个资源过期时间，然后拿过期时间和当前请求的时间做对比，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。
它的性能比Expires更好一点，两个可以同时启动也可以只启用一个，如果都启用的话优先cache control。
协商缓存 协商缓存主要是利用http respense header中的ETge和Lastmodified这两组。
协商缓存是在强缓存未命中的情况下，服务器向浏览器发送请求验证协商缓存是否命中。命中时状态码为304。
Lastmodified: 是一串时间字符：代表的是缓存过期的时间
浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上lastmodified，这个lastmodified表示这个资源在服务器上的最后修改时间。再次向服务端请求资源时，服务端就会返回加上If-Modified-Since的header,他表示的就是上一次请求时返回的Last-Modified的值。根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，来判断是否命中。命中就返回304状态码，同时让浏览器去缓存中拿资源。未命中则就从服务端获取资源。
缺点:当你在浏览器端打开缓存文件时，就是你没有修改文件，浏览器也会判定你修改了资源，这样就会导致协商缓存的判断有误。为了解决这个问题，于是又有了ETag来判断协商缓存。
ETag; 是一段特殊的字符，唯一标识的字符串。
浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上ETag，一段唯一辨识的字符串，再次请求时也会返回一段ETag，如果资源修改则返回的ETag是不一样的，所以通过判断两者是否相同，来判断资源是否修改，来判断是否命中缓存。
一般浏览器两种协商缓存的方式都会存在，防止Lastmodified的不稳定。
一般协商缓存都是配合着强缓存，如果没有强缓存，协商缓存就没有什么意义。协商缓存主要是为了帮助强缓存判断资源是否更新。
浏览器渲染原理 https://www.cnblogs.com/gwf93/p/10717281.html
浏览器的渲染主要是5个阶段；
浏览器读取html文件生成DOM树，他先将代码生成指令，这个过程叫做指令化，然后再指令化后，将这些指令生成node节点，这些node节点之间的关系就作为脐带，将这些节点串成一棵DOM树。 2.浏览器读取css文件，将css代码生成cssom。
3.合并DOM树和cssom，生成渲染树。这个过程浏览器递归每个node节点，并给节点一个样式规则并使用。这一步需要注意，display:none并不会出现再渲染树中，它会出现在第一步的DOM树中，里面还会出现注释和script标签。
4.渲染树布局 它会帮我们输出布置每个节点的出现的位置和大小等，就再浏览器端的位置，布置成一个一个的盒模型
渲染树绘制 它会将那些盒模型绘制上它的样式，色彩图片等等 考点1： 为什么操作 DOM 慢？
因为操作DOM用到了两条线程，js的引擎线程和渲染线程，js是单线程执行的，所以两天线程需要通信才能一起执行，这样会大大增加性能消耗。
操作DOM会引起回流和重绘。
考点2：同时加入10万条dom,如何实现不卡顿。 1.分页处理。
2.使用requestAnimationFrame来处理，每过16.6秒循环插入dom."><meta name=author content="卢穗杰"><link rel=canonical href=https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi/><meta name=google-site-verification content="xxx"><link rel=alternate type=application/rss+xml href=https://woshidashuaibi-lsj.github.io//index.xml title=lusuijie><script async src="https://www.googletagmanager.com/gtag/js?id=G-xxx"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-xxx",{anonymize_ip:!1})}</script><script async defer data-website-id=xxx src=https://xxx></script><meta property="og:title" content="浏览器端面试四大问：浏览器的缓存，浏览器渲染原理，存储，跨域（个人笔记）"><meta property="og:description" content="浏览器的缓存
https://www.cnblogs.com/lyzg/p/5125934.html
浏览器的缓存，缓存的一般是一些内存比较小的静态的资源。缓存的主要位置是:
Service Work
Memory Cache:浏览器自带，内存较小，速度较快
Disk Cache：存在本地，内存较大，加载速度较慢
Push Cache 缓存策略：
主要分为两种强缓存和协商缓存
强缓存 强缓存是利用Expires 或 cache control 这两个http response header 实现；
强缓存是浏览器现在缓存中查找是否有该资源。命中时状态码为200
Expires:是老浏览器使用的，是一串带有固定时间的字符。他表示的是这个资源缓存的过期时间。
它的工作原理是：
在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的Expires的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，就把exprice和当前的时间作比较，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。
它的缺点：因为它是和本地时间作比较的，当你的本地时间不准时它很有可能有误差。所以为了解决这个问题就有了cache control;
cache control: 是一串数字，以秒为单位，代表的是过多久时间过期。
它的工作原理是：
在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的cache control的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，他会根据第一次请求的时间和cache control的时间计算一个资源过期时间，然后拿过期时间和当前请求的时间做对比，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。
它的性能比Expires更好一点，两个可以同时启动也可以只启用一个，如果都启用的话优先cache control。
协商缓存 协商缓存主要是利用http respense header中的ETge和Lastmodified这两组。
协商缓存是在强缓存未命中的情况下，服务器向浏览器发送请求验证协商缓存是否命中。命中时状态码为304。
Lastmodified: 是一串时间字符：代表的是缓存过期的时间
浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上lastmodified，这个lastmodified表示这个资源在服务器上的最后修改时间。再次向服务端请求资源时，服务端就会返回加上If-Modified-Since的header,他表示的就是上一次请求时返回的Last-Modified的值。根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，来判断是否命中。命中就返回304状态码，同时让浏览器去缓存中拿资源。未命中则就从服务端获取资源。
缺点:当你在浏览器端打开缓存文件时，就是你没有修改文件，浏览器也会判定你修改了资源，这样就会导致协商缓存的判断有误。为了解决这个问题，于是又有了ETag来判断协商缓存。
ETag; 是一段特殊的字符，唯一标识的字符串。
浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上ETag，一段唯一辨识的字符串，再次请求时也会返回一段ETag，如果资源修改则返回的ETag是不一样的，所以通过判断两者是否相同，来判断资源是否修改，来判断是否命中缓存。
一般浏览器两种协商缓存的方式都会存在，防止Lastmodified的不稳定。
一般协商缓存都是配合着强缓存，如果没有强缓存，协商缓存就没有什么意义。协商缓存主要是为了帮助强缓存判断资源是否更新。
浏览器渲染原理 https://www.cnblogs.com/gwf93/p/10717281.html
浏览器的渲染主要是5个阶段；
浏览器读取html文件生成DOM树，他先将代码生成指令，这个过程叫做指令化，然后再指令化后，将这些指令生成node节点，这些node节点之间的关系就作为脐带，将这些节点串成一棵DOM树。 2.浏览器读取css文件，将css代码生成cssom。
3.合并DOM树和cssom，生成渲染树。这个过程浏览器递归每个node节点，并给节点一个样式规则并使用。这一步需要注意，display:none并不会出现再渲染树中，它会出现在第一步的DOM树中，里面还会出现注释和script标签。
4.渲染树布局 它会帮我们输出布置每个节点的出现的位置和大小等，就再浏览器端的位置，布置成一个一个的盒模型
渲染树绘制 它会将那些盒模型绘制上它的样式，色彩图片等等 考点1： 为什么操作 DOM 慢？
因为操作DOM用到了两条线程，js的引擎线程和渲染线程，js是单线程执行的，所以两天线程需要通信才能一起执行，这样会大大增加性能消耗。
操作DOM会引起回流和重绘。
考点2：同时加入10万条dom,如何实现不卡顿。 1.分页处理。
2.使用requestAnimationFrame来处理，每过16.6秒循环插入dom."><meta property="og:type" content="article"><meta property="og:url" content="https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-06-11T00:00:00+00:00"><meta property="article:modified_time" content="2020-06-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="浏览器端面试四大问：浏览器的缓存，浏览器渲染原理，存储，跨域（个人笔记）"><meta name=twitter:description content="浏览器的缓存
https://www.cnblogs.com/lyzg/p/5125934.html
浏览器的缓存，缓存的一般是一些内存比较小的静态的资源。缓存的主要位置是:
Service Work
Memory Cache:浏览器自带，内存较小，速度较快
Disk Cache：存在本地，内存较大，加载速度较慢
Push Cache 缓存策略：
主要分为两种强缓存和协商缓存
强缓存 强缓存是利用Expires 或 cache control 这两个http response header 实现；
强缓存是浏览器现在缓存中查找是否有该资源。命中时状态码为200
Expires:是老浏览器使用的，是一串带有固定时间的字符。他表示的是这个资源缓存的过期时间。
它的工作原理是：
在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的Expires的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，就把exprice和当前的时间作比较，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。
它的缺点：因为它是和本地时间作比较的，当你的本地时间不准时它很有可能有误差。所以为了解决这个问题就有了cache control;
cache control: 是一串数字，以秒为单位，代表的是过多久时间过期。
它的工作原理是：
在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的cache control的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，他会根据第一次请求的时间和cache control的时间计算一个资源过期时间，然后拿过期时间和当前请求的时间做对比，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。
它的性能比Expires更好一点，两个可以同时启动也可以只启用一个，如果都启用的话优先cache control。
协商缓存 协商缓存主要是利用http respense header中的ETge和Lastmodified这两组。
协商缓存是在强缓存未命中的情况下，服务器向浏览器发送请求验证协商缓存是否命中。命中时状态码为304。
Lastmodified: 是一串时间字符：代表的是缓存过期的时间
浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上lastmodified，这个lastmodified表示这个资源在服务器上的最后修改时间。再次向服务端请求资源时，服务端就会返回加上If-Modified-Since的header,他表示的就是上一次请求时返回的Last-Modified的值。根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，来判断是否命中。命中就返回304状态码，同时让浏览器去缓存中拿资源。未命中则就从服务端获取资源。
缺点:当你在浏览器端打开缓存文件时，就是你没有修改文件，浏览器也会判定你修改了资源，这样就会导致协商缓存的判断有误。为了解决这个问题，于是又有了ETag来判断协商缓存。
ETag; 是一段特殊的字符，唯一标识的字符串。
浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上ETag，一段唯一辨识的字符串，再次请求时也会返回一段ETag，如果资源修改则返回的ETag是不一样的，所以通过判断两者是否相同，来判断资源是否修改，来判断是否命中缓存。
一般浏览器两种协商缓存的方式都会存在，防止Lastmodified的不稳定。
一般协商缓存都是配合着强缓存，如果没有强缓存，协商缓存就没有什么意义。协商缓存主要是为了帮助强缓存判断资源是否更新。
浏览器渲染原理 https://www.cnblogs.com/gwf93/p/10717281.html
浏览器的渲染主要是5个阶段；
浏览器读取html文件生成DOM树，他先将代码生成指令，这个过程叫做指令化，然后再指令化后，将这些指令生成node节点，这些node节点之间的关系就作为脐带，将这些节点串成一棵DOM树。 2.浏览器读取css文件，将css代码生成cssom。
3.合并DOM树和cssom，生成渲染树。这个过程浏览器递归每个node节点，并给节点一个样式规则并使用。这一步需要注意，display:none并不会出现再渲染树中，它会出现在第一步的DOM树中，里面还会出现注释和script标签。
4.渲染树布局 它会帮我们输出布置每个节点的出现的位置和大小等，就再浏览器端的位置，布置成一个一个的盒模型
渲染树绘制 它会将那些盒模型绘制上它的样式，色彩图片等等 考点1： 为什么操作 DOM 慢？
因为操作DOM用到了两条线程，js的引擎线程和渲染线程，js是单线程执行的，所以两天线程需要通信才能一起执行，这样会大大增加性能消耗。
操作DOM会引起回流和重绘。
考点2：同时加入10万条dom,如何实现不卡顿。 1.分页处理。
2.使用requestAnimationFrame来处理，每过16.6秒循环插入dom."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://woshidashuaibi-lsj.github.io/blog/"},{"@type":"ListItem","position":2,"name":"浏览器端面试四大问：浏览器的缓存，浏览器渲染原理，存储，跨域（个人笔记）","item":"https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"浏览器端面试四大问：浏览器的缓存，浏览器渲染原理，存储，跨域（个人笔记）","name":"浏览器端面试四大问：浏览器的缓存，浏览器渲染原理，存储，跨域（个人笔记）","description":"浏览器的缓存\nhttps://www.cnblogs.com/lyzg/p/5125934.html\n浏览器的缓存，缓存的一般是一些内存比较小的静态的资源。缓存的主要位置是:\nService Work\nMemory Cache:浏览器自带，内存较小，速度较快\nDisk Cache：存在本地，内存较大，加载速度较慢\nPush Cache 缓存策略：\n主要分为两种强缓存和协商缓存\n强缓存 强缓存是利用Expires 或 cache control 这两个http response header 实现；\n强缓存是浏览器现在缓存中查找是否有该资源。命中时状态码为200\nExpires:是老浏览器使用的，是一串带有固定时间的字符。他表示的是这个资源缓存的过期时间。\n它的工作原理是：\n在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的Expires的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，就把exprice和当前的时间作比较，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。\n它的缺点：因为它是和本地时间作比较的，当你的本地时间不准时它很有可能有误差。所以为了解决这个问题就有了cache control;\ncache control: 是一串数字，以秒为单位，代表的是过多久时间过期。\n它的工作原理是：\n在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的cache control的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，他会根据第一次请求的时间和cache control的时间计算一个资源过期时间，然后拿过期时间和当前请求的时间做对比，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。\n它的性能比Expires更好一点，两个可以同时启动也可以只启用一个，如果都启用的话优先cache control。\n协商缓存 协商缓存主要是利用http respense header中的ETge和Lastmodified这两组。\n协商缓存是在强缓存未命中的情况下，服务器向浏览器发送请求验证协商缓存是否命中。命中时状态码为304。\nLastmodified: 是一串时间字符：代表的是缓存过期的时间\n浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上lastmodified，这个lastmodified表示这个资源在服务器上的最后修改时间。再次向服务端请求资源时，服务端就会返回加上If-Modified-Since的header,他表示的就是上一次请求时返回的Last-Modified的值。根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，来判断是否命中。命中就返回304状态码，同时让浏览器去缓存中拿资源。未命中则就从服务端获取资源。\n缺点:当你在浏览器端打开缓存文件时，就是你没有修改文件，浏览器也会判定你修改了资源，这样就会导致协商缓存的判断有误。为了解决这个问题，于是又有了ETag来判断协商缓存。\nETag; 是一段特殊的字符，唯一标识的字符串。\n浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上ETag，一段唯一辨识的字符串，再次请求时也会返回一段ETag，如果资源修改则返回的ETag是不一样的，所以通过判断两者是否相同，来判断资源是否修改，来判断是否命中缓存。\n一般浏览器两种协商缓存的方式都会存在，防止Lastmodified的不稳定。\n一般协商缓存都是配合着强缓存，如果没有强缓存，协商缓存就没有什么意义。协商缓存主要是为了帮助强缓存判断资源是否更新。\n浏览器渲染原理 https://www.cnblogs.com/gwf93/p/10717281.html\n浏览器的渲染主要是5个阶段；\n浏览器读取html文件生成DOM树，他先将代码生成指令，这个过程叫做指令化，然后再指令化后，将这些指令生成node节点，这些node节点之间的关系就作为脐带，将这些节点串成一棵DOM树。 2.浏览器读取css文件，将css代码生成cssom。\n3.合并DOM树和cssom，生成渲染树。这个过程浏览器递归每个node节点，并给节点一个样式规则并使用。这一步需要注意，display:none并不会出现再渲染树中，它会出现在第一步的DOM树中，里面还会出现注释和script标签。\n4.渲染树布局 它会帮我们输出布置每个节点的出现的位置和大小等，就再浏览器端的位置，布置成一个一个的盒模型\n渲染树绘制 它会将那些盒模型绘制上它的样式，色彩图片等等 考点1： 为什么操作 DOM 慢？\n因为操作DOM用到了两条线程，js的引擎线程和渲染线程，js是单线程执行的，所以两天线程需要通信才能一起执行，这样会大大增加性能消耗。\n操作DOM会引起回流和重绘。\n考点2：同时加入10万条dom,如何实现不卡顿。 1.分页处理。\n2.使用requestAnimationFrame来处理，每过16.6秒循环插入dom.","keywords":["笔记"],"articleBody":"浏览器的缓存\nhttps://www.cnblogs.com/lyzg/p/5125934.html\n浏览器的缓存，缓存的一般是一些内存比较小的静态的资源。缓存的主要位置是:\nService Work\nMemory Cache:浏览器自带，内存较小，速度较快\nDisk Cache：存在本地，内存较大，加载速度较慢\nPush Cache 缓存策略：\n主要分为两种强缓存和协商缓存\n强缓存 强缓存是利用Expires 或 cache control 这两个http response header 实现；\n强缓存是浏览器现在缓存中查找是否有该资源。命中时状态码为200\nExpires:是老浏览器使用的，是一串带有固定时间的字符。他表示的是这个资源缓存的过期时间。\n它的工作原理是：\n在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的Expires的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，就把exprice和当前的时间作比较，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。\n它的缺点：因为它是和本地时间作比较的，当你的本地时间不准时它很有可能有误差。所以为了解决这个问题就有了cache control;\ncache control: 是一串数字，以秒为单位，代表的是过多久时间过期。\n它的工作原理是：\n在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的cache control的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，他会根据第一次请求的时间和cache control的时间计算一个资源过期时间，然后拿过期时间和当前请求的时间做对比，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。\n它的性能比Expires更好一点，两个可以同时启动也可以只启用一个，如果都启用的话优先cache control。\n协商缓存 协商缓存主要是利用http respense header中的ETge和Lastmodified这两组。\n协商缓存是在强缓存未命中的情况下，服务器向浏览器发送请求验证协商缓存是否命中。命中时状态码为304。\nLastmodified: 是一串时间字符：代表的是缓存过期的时间\n浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上lastmodified，这个lastmodified表示这个资源在服务器上的最后修改时间。再次向服务端请求资源时，服务端就会返回加上If-Modified-Since的header,他表示的就是上一次请求时返回的Last-Modified的值。根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，来判断是否命中。命中就返回304状态码，同时让浏览器去缓存中拿资源。未命中则就从服务端获取资源。\n缺点:当你在浏览器端打开缓存文件时，就是你没有修改文件，浏览器也会判定你修改了资源，这样就会导致协商缓存的判断有误。为了解决这个问题，于是又有了ETag来判断协商缓存。\nETag; 是一段特殊的字符，唯一标识的字符串。\n浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上ETag，一段唯一辨识的字符串，再次请求时也会返回一段ETag，如果资源修改则返回的ETag是不一样的，所以通过判断两者是否相同，来判断资源是否修改，来判断是否命中缓存。\n一般浏览器两种协商缓存的方式都会存在，防止Lastmodified的不稳定。\n一般协商缓存都是配合着强缓存，如果没有强缓存，协商缓存就没有什么意义。协商缓存主要是为了帮助强缓存判断资源是否更新。\n浏览器渲染原理 https://www.cnblogs.com/gwf93/p/10717281.html\n浏览器的渲染主要是5个阶段；\n浏览器读取html文件生成DOM树，他先将代码生成指令，这个过程叫做指令化，然后再指令化后，将这些指令生成node节点，这些node节点之间的关系就作为脐带，将这些节点串成一棵DOM树。 2.浏览器读取css文件，将css代码生成cssom。\n3.合并DOM树和cssom，生成渲染树。这个过程浏览器递归每个node节点，并给节点一个样式规则并使用。这一步需要注意，display:none并不会出现再渲染树中，它会出现在第一步的DOM树中，里面还会出现注释和script标签。\n4.渲染树布局 它会帮我们输出布置每个节点的出现的位置和大小等，就再浏览器端的位置，布置成一个一个的盒模型\n渲染树绘制 它会将那些盒模型绘制上它的样式，色彩图片等等 考点1： 为什么操作 DOM 慢？\n因为操作DOM用到了两条线程，js的引擎线程和渲染线程，js是单线程执行的，所以两天线程需要通信才能一起执行，这样会大大增加性能消耗。\n操作DOM会引起回流和重绘。\n考点2：同时加入10万条dom,如何实现不卡顿。 1.分页处理。\n2.使用requestAnimationFrame来处理，每过16.6秒循环插入dom.\n3.使用虚拟DOM,只加载可视区域的dom,加载更多的时候，用虚拟DOM去替换，https://bvaughn.github.io/react-virtualized/#/components/List\n考点3：优化，减少阻塞\n减少选择器的使用，这样能减少DOM遍历的层级，降低渲染的文件的大小 2.script标签会阻塞渲染进程，所以我们的script代码应该写在html文件的下面。\n3.没有任何依赖的js文件我们可以加上asyac属性，这样就不会影响渲染的进度。\n考点4：重绘和回流 重绘不改变布局，只改变一些颜色什么的\n回流会改变布局。\n回流一定会引发重绘。\n浏览器的存储 https://juejin.im/post/6844903812092674061#heading-2\nCookie,LocalStorage,sessionStorage,IndexedDB Cookie 浏览器是无状态的，他无法记住浏览器上一步做的是什么，所以很多功能无法实现，比如购物车，所以浏览器创建cookie来使用，用于保存用户的状态，在购物东西时cookie就好像一辆购物车，用来保存用户选购的商品信息，它在浏览器和服务器之间来回传输信息。\nCookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储。通过保存用户的信息，来保存登录状态，登录还刷新还能回到原来的状态。可以保存一段时间。\n缺点：内存较小一般就几k大小，所以只能保存用户信息不能保存大文件内容。\ncookie过多可能会带来过的性能消耗。\ncookie还存在一定的安全性。\nLocalStorage 内存较大有5M左右，除非被清除否则永久保存，接口容易封装，仅在浏览器中保存，不参与通信\nsessionStorage 内存较大有5M左右，关闭页面就消失，接口容易封装，仅在浏览器中保存，不参与通信\nIndexedDB 内存无线，永久保存。\n跨域 数据的请求都要遵循同源策略，既需要同域名，同端口，同协议。所以违反了这个规则则就算跨域了。\n解决跨域的四个方法：\nFrom表单能够帮我们跨域请求信息。疯狂发送请求\njsonp 利用的没有跨域限制请求\ncors 后端设置允许跨域，或者搞个白名单，允许那些能跨域请求\nnginx 代理 最后： 有时间再整理跨域和存储。\n","wordCount":"107","inLanguage":"zh","datePublished":"2020-06-11T00:00:00Z","dateModified":"2020-06-11T00:00:00Z","author":{"@type":"Person","name":"卢穗杰"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi/"},"publisher":{"@type":"Organization","name":"lusuijie","logo":{"@type":"ImageObject","url":"https://woshidashuaibi-lsj.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.ec28f09e946fc0df77c187fcd0d0ebde58fca6de8efb8e1620f3d45c32d4da88.css integrity="sha256-7CjwnpRvwN93wYf80NDr3lj8pt6O+44WIPPUXDLU2og=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>主页
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>分类</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>历史文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/woshidashuaibi-lsj><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>浏览器端面试四大问：浏览器的缓存，浏览器渲染原理，存储，跨域（个人笔记）</h1></header><p><small>2020年6月11日&nbsp;· 107 字&nbsp;· 1 分钟</small><p><div class=blog-toc><nav id=TableOfContents></nav></div><section class=blog-content><p>浏览器的缓存</p><p><a href=https://www.cnblogs.com/lyzg/p/5125934.html>https://www.cnblogs.com/lyzg/p/5125934.html</a></p><p>浏览器的缓存，缓存的一般是一些内存比较小的静态的资源。缓存的主要位置是:</p><p>Service Work</p><p>Memory Cache:浏览器自带，内存较小，速度较快</p><p>Disk Cache：存在本地，内存较大，加载速度较慢</p><p>Push Cache
缓存策略：</p><p>主要分为两种强缓存和协商缓存</p><p>强缓存
强缓存是利用Expires 或 cache control 这两个http response header 实现；</p><p>强缓存是浏览器现在缓存中查找是否有该资源。命中时状态码为200</p><p>Expires:是老浏览器使用的，是一串带有固定时间的字符。他表示的是这个资源缓存的过期时间。</p><p>它的工作原理是：</p><p>在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的Expires的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，就把exprice和当前的时间作比较，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。</p><p>它的缺点：因为它是和本地时间作比较的，当你的本地时间不准时它很有可能有误差。所以为了解决这个问题就有了cache control;</p><p>cache control: 是一串数字，以秒为单位，代表的是过多久时间过期。</p><p>它的工作原理是：</p><p>在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的cache control的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，他会根据第一次请求的时间和cache control的时间计算一个资源过期时间，然后拿过期时间和当前请求的时间做对比，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。</p><p>它的性能比Expires更好一点，两个可以同时启动也可以只启用一个，如果都启用的话优先cache control。</p><p>协商缓存
协商缓存主要是利用http respense header中的ETge和Lastmodified这两组。</p><p>协商缓存是在强缓存未命中的情况下，服务器向浏览器发送请求验证协商缓存是否命中。命中时状态码为304。</p><p>Lastmodified:
是一串时间字符：代表的是缓存过期的时间</p><p>浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上lastmodified，这个lastmodified表示这个资源在服务器上的最后修改时间。再次向服务端请求资源时，服务端就会返回加上If-Modified-Since的header,他表示的就是上一次请求时返回的Last-Modified的值。根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，来判断是否命中。命中就返回304状态码，同时让浏览器去缓存中拿资源。未命中则就从服务端获取资源。</p><p>缺点:当你在浏览器端打开缓存文件时，就是你没有修改文件，浏览器也会判定你修改了资源，这样就会导致协商缓存的判断有误。为了解决这个问题，于是又有了ETag来判断协商缓存。</p><p>ETag;
是一段特殊的字符，唯一标识的字符串。</p><p>浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上ETag，一段唯一辨识的字符串，再次请求时也会返回一段ETag，如果资源修改则返回的ETag是不一样的，所以通过判断两者是否相同，来判断资源是否修改，来判断是否命中缓存。</p><p>一般浏览器两种协商缓存的方式都会存在，防止Lastmodified的不稳定。</p><p>一般协商缓存都是配合着强缓存，如果没有强缓存，协商缓存就没有什么意义。协商缓存主要是为了帮助强缓存判断资源是否更新。</p><p>浏览器渲染原理
<a href=https://www.cnblogs.com/gwf93/p/10717281.html>https://www.cnblogs.com/gwf93/p/10717281.html</a></p><p>浏览器的渲染主要是5个阶段；</p><ol><li>浏览器读取html文件生成DOM树，他先将代码生成指令，这个过程叫做指令化，然后再指令化后，将这些指令生成node节点，这些node节点之间的关系就作为脐带，将这些节点串成一棵DOM树。</li></ol><p>2.浏览器读取css文件，将css代码生成cssom。</p><p>3.合并DOM树和cssom，生成渲染树。这个过程浏览器递归每个node节点，并给节点一个样式规则并使用。这一步需要注意，display:none并不会出现再渲染树中，它会出现在第一步的DOM树中，里面还会出现注释和script标签。</p><p>4.渲染树布局 它会帮我们输出布置每个节点的出现的位置和大小等，就再浏览器端的位置，布置成一个一个的盒模型</p><ol start=5><li>渲染树绘制 它会将那些盒模型绘制上它的样式，色彩图片等等</li></ol><p>考点1： 为什么操作 DOM 慢？</p><ol><li><p>因为操作DOM用到了两条线程，js的引擎线程和渲染线程，js是单线程执行的，所以两天线程需要通信才能一起执行，这样会大大增加性能消耗。</p></li><li><p>操作DOM会引起回流和重绘。</p></li></ol><p>考点2：同时加入10万条dom,如何实现不卡顿。
1.分页处理。</p><p>2.使用requestAnimationFrame来处理，每过16.6秒循环插入dom.</p><p>3.使用虚拟DOM,只加载可视区域的dom,加载更多的时候，用虚拟DOM去替换，https://bvaughn.github.io/react-virtualized/#/components/List</p><p>考点3：优化，减少阻塞</p><ol><li>减少选择器的使用，这样能减少DOM遍历的层级，降低渲染的文件的大小</li></ol><p>2.script标签会阻塞渲染进程，所以我们的script代码应该写在html文件的下面。</p><p>3.没有任何依赖的js文件我们可以加上asyac属性，这样就不会影响渲染的进度。</p><p>考点4：重绘和回流
重绘不改变布局，只改变一些颜色什么的</p><p>回流会改变布局。</p><p>回流一定会引发重绘。</p><p>浏览器的存储
<a href=https://juejin.im/post/6844903812092674061#heading-2>https://juejin.im/post/6844903812092674061#heading-2</a></p><p>Cookie,LocalStorage,sessionStorage,IndexedDB
Cookie
浏览器是无状态的，他无法记住浏览器上一步做的是什么，所以很多功能无法实现，比如购物车，所以浏览器创建cookie来使用，用于保存用户的状态，在购物东西时cookie就好像一辆购物车，用来保存用户选购的商品信息，它在浏览器和服务器之间来回传输信息。</p><p>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储。通过保存用户的信息，来保存登录状态，登录还刷新还能回到原来的状态。可以保存一段时间。</p><p>缺点：内存较小一般就几k大小，所以只能保存用户信息不能保存大文件内容。</p><p>cookie过多可能会带来过的性能消耗。</p><p>cookie还存在一定的安全性。</p><p>LocalStorage
内存较大有5M左右，除非被清除否则永久保存，接口容易封装，仅在浏览器中保存，不参与通信</p><p>sessionStorage
内存较大有5M左右，关闭页面就消失，接口容易封装，仅在浏览器中保存，不参与通信</p><p>IndexedDB
内存无线，永久保存。</p><p>跨域
数据的请求都要遵循同源策略，既需要同域名，同端口，同协议。所以违反了这个规则则就算跨域了。</p><p>解决跨域的四个方法：</p><p>From表单能够帮我们跨域请求信息。疯狂发送请求</p><p>jsonp 利用的没有跨域限制请求</p><p>cors 后端设置允许跨域，或者搞个白名单，允许那些能跨域请求</p><p>nginx 代理
最后：
有时间再整理跨域和存储。</p></section><div class=paginator><a class=prev href=https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi-anquan/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>由前端网络安全到http，https和浏览器的存储（个人笔记）</span></a>
<a class=next href=https://woshidashuaibi-lsj.github.io/blog/videos/><span>Videos</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","woshidashuaibi-lsj/lusuijie.github.io"),s.setAttribute("data-repo-id","R_kgDOLUkL3w"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOLUkL384CdVmA"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","en"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://woshidashuaibi-lsj.github.io/>lusuijie</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>