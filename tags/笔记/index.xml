<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>笔记 on lusuijie</title><link>https://woshidashuaibi-lsj.github.io/tags/%E7%AC%94%E8%AE%B0/</link><description>Recent content in 笔记 on lusuijie</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 17 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://woshidashuaibi-lsj.github.io/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>由前端网络安全到http，https和浏览器的存储（个人笔记）</title><link>https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi-anquan/</link><pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate><guid>https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi-anquan/</guid><description>&lt;p>常见的web攻击方式&lt;/p>
&lt;p>-XSS&lt;/p>
&lt;ul>
&lt;li>CSRF&lt;/li>
&lt;li>点击劫持&lt;/li>
&lt;li>SQL注入&lt;/li>
&lt;li>OS注入&lt;/li>
&lt;li>请求劫持&lt;/li>
&lt;li>DDOS
XSS
参考：https://juejin.im/post/6844903685122703367#heading-18&lt;/li>
&lt;/ul>
&lt;p>Cross-Site scripting 跨站脚本攻击，因为和css同名所以改成xss。&lt;/p>
&lt;p>就比如一个掘金写文章的页面，假设掘金没有做xss攻击的脚本，我在我的文章里面写了&lt;!-- raw HTML omitted -->alert(&amp;ldquo;攻击&amp;rdquo;)&lt;!-- raw HTML omitted -->，那么当用户点开我的文章的时候就会有个alert提醒。过分一点，就用一个while循环无线重复alert。也有可能写上一些js代码获取用户的cookie,来帮助黑客恶意操作网站。&lt;/p>
&lt;p>这是存储型的xss攻击。主要运用再存储到数据库这种的网站进行攻击。&lt;/p>
&lt;p>还有一个反射型的xss攻击，&lt;/p>
&lt;p>&amp;lt;input type=&amp;ldquo;text&amp;rdquo; value=&amp;quot;&amp;lt;%= getParameter(&amp;ldquo;keyword&amp;rdquo;) %&amp;gt;&amp;quot;&amp;gt;
&lt;!-- raw HTML omitted -->搜索&lt;!-- raw HTML omitted -->&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->alert(&amp;lsquo;XSS&amp;rsquo;);&lt;!-- raw HTML omitted -->&amp;quot;&amp;gt;
&lt;!-- raw HTML omitted -->搜索&lt;!-- raw HTML omitted -->&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>反射性的xss攻击是在url上操作的，如网站搜索、跳转等&lt;/p>
&lt;p>DOM 型 XSS 的攻击步骤：&lt;/p>
&lt;p>攻击者构造出特殊的 URL，其中包含恶意代码。
用户打开带有恶意代码的 URL。
用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。&lt;/p>
&lt;p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。&lt;/p>
&lt;p>课外知识热点：&lt;/p>
&lt;p>曾经在猫扑大杂烩中存在这样一个XSS漏洞，在用户发表回复的时候，程序对用户发表的内容做了严格的过滤，但是我不知道为什么，当用户编辑回复内容再次发表的时候，他却采用了另外一种不同的过滤方式，而这种过滤方式显然是不严密的，因此导致了XSS漏洞的出现。试想一下，像猫扑这样的大型社区，如果在一篇热帖中，利用XSS漏洞来使所有的浏览这篇帖子的用户都在不知不觉之中访问到了另外一个站点，如果这个站点同样是大型站点还好，但如果是中小型站点那就悲剧了，这将会引来多大的流量啊！更可怕的是，这些流量全部都是真实有效的！&lt;/p>
&lt;p>解决方案：
对一些特殊的符号进行转义什么的，比如&amp;lt; &amp;gt; 什么的，&lt;/p>
&lt;p>最好的办法就是配置白名单和黑名单。&lt;/p>
&lt;p>CSRF
参考：https://www.bilibili.com/video/BV1iW411171s?from=search&amp;amp;seid=6829106872112135941&lt;/p>
&lt;p>(Cross Site Request Forgery) 跨站请求伪造。
攻击者盗用你的身份，以你的名义去发送一些恶意请求。&lt;/p>
&lt;p>比如你登陆进一个页面，然后进入转账页面&lt;/p>
&lt;p>此时页面时保留了你的登录信息的，你没有关闭此页面，而是进入到一个黑客网站。如下网站的源代码，他的图片的路劲就是你转账的路劲。所以此时你的账户会被转账。&lt;/p>
&lt;p>解决办法将get请求改成post请求这样就不能看到你的路径了&lt;/p>
&lt;p>但是黑客同样有办法：通过表单from来提交接口&lt;/p>
&lt;ol>
&lt;li>
&lt;p>解决方法加入一个验证码，因为他只是构造了一个请求，不能操作我们的也页面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>验证Refer 即同源策略，不是同域名同端口同协议的拒绝请求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在form表单或头信息中传递token,token存储在服务端，服务端通过拦截器验证有效性，检验失败的拒绝请求。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>点击劫持
点击劫持是一种视觉欺骗的攻击手段,攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页， 应将iframe设置为透明，在页面中透出一个按钮诱导用户点击。就比如电影天堂的网站，当我随便点击一个电影。&lt;/p>
&lt;p>结果就进入了一个其他页面（还挺想玩一玩的TvT）。&lt;/p>
&lt;p>这就是典型的点击劫持。页面使用 iframe 元素，将 iframe 透明化。就是吧这个跳转透明化。&lt;/p>
&lt;p>解决办法：&lt;/p>
&lt;ol>
&lt;li>X-FRAME-OPTIONS 是一个HTTP响应头，就是为了防御iframe嵌套的点击劫持攻击
DENY 页面不允许通过iframe方式展示
SAPMEORIGIN 页面可以相同域名下通过iframe方式展示
ALLOW-FROM 页面可以在指定来源的iframe中展示
SQL注入
sql注入是黑客通过当你输入密码的时候判断你的密码是否和我数据课里面的密码是否相同，黑客通过1&amp;rsquo;or'1&amp;rsquo;=&amp;lsquo;1你前面的密码可能不是相同的但是后面的1=1返回的时true,所以系统会判断你的密码时正确的。&lt;/li>
&lt;/ol>
&lt;p>解决方法:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入的变量嵌套到SQL语句中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对进入数据库的特殊字符(&amp;rsquo;,&amp;quot;,,&amp;lt;,&amp;gt;,&amp;amp;)等进行转义
OS注入
和sql注入差不多的原理，不过它是针对操作系统的，通过shell偷偷开启你的终端，操作你的电脑。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>解决方法：同sql解决方法&lt;/p>
&lt;p>请求劫持
DNS劫持：DNS服务器（DNS解析各个步骤）被纂改，修改域名解析的结果，使得访问到的不是预期的ip。&lt;/p>
&lt;p>http劫持: 运营商劫持。升级为https&lt;/p>
&lt;p>DDOS
distributed denial of service（分布式拒绝服务）
DDOS不是一个攻击的名称而是指一群攻击的合称。举个例子一个餐厅一次只能容纳300人一起吃饭，但是黑客一次叫3000个人去餐厅吃饭，餐厅根本容不下这么多人，于是就瘫痪了。DDOS就是这样的原理操作了，我同时叫100个ip地址同时发送请求，你的网站承受不了如此大的点击量。&lt;/p>
&lt;p>解决方案&lt;/p>
&lt;p>1.备用一个网站（全静态的网站）。如果瘫痪了先暂时上这个网站。&lt;/p>
&lt;p>2。http请求拦截，如果同一个ip一直恶意请求，就直接把这个ip给封了。&lt;/p>
&lt;p>3.有也那种IP你根本找不到的，那就可以带宽扩容，简单点就是你的饭店原来只能300人，现在我装修3000人也能坐的下，但是成本大，就给服务器怎加容量，这种看不到ip的攻击，黑客的成本也大。&lt;/p>
&lt;p>以上就是前端常见的面试常问的网络安全放面的考点。上面也简单的说到过get 和post,http和https。下面我就顺带着一起讲一下，因为他们也是常考点。&lt;/p>
&lt;p>get和post的区别
先从原理上来了解get和post,先将两个知识点，幂等和副作用。&lt;/p>
&lt;p>副作用: 服务器上的资源是否改变。比如搜索服务器上的资源资源没有改动，是无副作用的。注册账号，资源改动是，副作用的。&lt;/p>
&lt;p>幂等：指的是发送M 和 N 次请求(M N 不相等且都大于1)，服务器上的资源状态是否改变。比如对文章修改10次和11次是幂等的。而注册10次和注册11次是一样的，是不幂等的。&lt;/p>
&lt;p>get一般用于无副作用幂等的。即资源和它的状态都不改动。&lt;/p>
&lt;p>post一般用于副作用不幂等的。即资源和它的状态都改动了。&lt;/p>
&lt;p>先前上面也提到过，get请求的参数会被携带在url里面，很容易被人利用，而post不会，所以post比get更加安全一点。
post支持更多的编码类型，且不被数据类型所限制。
get请求能缓存，post不能
http和https
http 是基于TCP/IP来传送超文本数据的。&lt;/p>
&lt;p>https是基于http的基础上加了一个TLS协议。&lt;/p>
&lt;p>TLS是使用了两种加密方式：&lt;/p>
&lt;p>对称加密和非对称加密&lt;/p>
&lt;p>对称加密：是指双方都有相同的密钥，双方用同一套加密规则加密，然后解密。&lt;/p>
&lt;p>非对称加密：是我向大众宣布我的数据加密方法，然后解密方法只在我这里。&lt;/p>
&lt;p>一般TLS加密是两种方法合并使用，我先用非对称加密，向大众发布我的加密方式，然后别人用这种加密方式，加密它的密钥给我，然后我就有了它的密钥，然后我们有了相同的密钥，这时候就用对称加密。&lt;/p>
&lt;hr>
&lt;p>更新：看了一些大佬的文章，感觉自己http和https还是没有悟到，在整理整理这里。&lt;/p>
&lt;p>TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分&lt;/p>
&lt;p>http协议以明文的方式发送传输数据，不提供任何加密方式，所以就很有可能被人窃取数据，并且读懂数据内容，所以http不能用来传输一些很重要的信息，比如密码什么的。&lt;/p>
&lt;p>https协议则是以http为基础来传输数据，不过在这上面加了一层SSL协议，用来加密传输的数据。&lt;/p>
&lt;p>https协议使用的是443端口，http是80端口。&lt;/p>
&lt;p>https工作原理：&lt;/p>
&lt;p>https协议是需要申请证书的，这个证书就是一对私钥和密钥。客户端会检查对方的证书是否安全，不安全就会弹出证书安全的警告，如果安全就会用它的公钥对你私钥也就是一段随机值进行加密，发送给服务端，服务端和客户端就可以进行上面提到的对称加密了。&lt;/p>
&lt;hr>
&lt;p>HTTP1.0，HTTP1.1，HTTP2.0
http1.0
特性：无状态，无连接的&lt;/p>
&lt;p>无状态是指每次都无法保留用户的登陆记录和状态等等，只能通过cookie session来保存（服务器不跟踪不记录请求过的状态）&lt;/p>
&lt;p>无连接是指每次发送请求都需要tcp三次握手，效率很低，并且在前一个请求响应到达之前才能发送下一个请求，如果前面的阻塞的话后面的都会被阻塞。&lt;/p>
&lt;p>http1.1
为了解决http1.0的问题，http1.1新增了一些新特性：长连接，管道化，缓存处理，断点传输。&lt;/p>
&lt;p>长连接：数据传输完毕不关闭tcp连接，继续用这个通道传输数据。&lt;/p>
&lt;p>管道化：没有管道化和长连接时，我们时 请求一=》响应一 请求二 =》响应二 请求三 =》 响应三。有管道化和长连接以后，我们 请求一 =》请求二=》请求三 =》响应一=》 响应二=》 响应三 管道化就不需要等到上一个请求响应之后才发第二个请求，但是即使你的请求二比请求一先完成但是响应依旧要按照顺序响应。&lt;/p>
&lt;p>缓存处理：第一次请求到的一些数据放到缓存中，这样下次请求的时候就可以从本地缓存中拿。&lt;/p>
&lt;p>http2.0
二进制分帧
多路复用： 在共享TCP链接的基础上同时发送请求和响应
头部压缩
服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求
二进制分帧:&lt;/p>
&lt;p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码&lt;/p>
&lt;p>多路复用:&lt;/p>
&lt;p>基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来&lt;/p>
&lt;p>区别：&lt;/p>
&lt;p>http1.0 到http1.1的主要区别，就是从无连接到长连接
http2.0对比1.X版本主要区别就是多路复用
最后：
有时间再把cookie,token哪几种存储方式一起加到这里吧。&lt;/p></description></item><item><title>浏览器端面试四大问：浏览器的缓存，浏览器渲染原理，存储，跨域（个人笔记）</title><link>https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi/</link><pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate><guid>https://woshidashuaibi-lsj.github.io/blog/riji-liulanqi/</guid><description>&lt;p>浏览器的缓存&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/lyzg/p/5125934.html">https://www.cnblogs.com/lyzg/p/5125934.html&lt;/a>&lt;/p>
&lt;p>浏览器的缓存，缓存的一般是一些内存比较小的静态的资源。缓存的主要位置是:&lt;/p>
&lt;p>Service Work&lt;/p>
&lt;p>Memory Cache:浏览器自带，内存较小，速度较快&lt;/p>
&lt;p>Disk Cache：存在本地，内存较大，加载速度较慢&lt;/p>
&lt;p>Push Cache
缓存策略：&lt;/p>
&lt;p>主要分为两种强缓存和协商缓存&lt;/p>
&lt;p>强缓存
强缓存是利用Expires 或 cache control 这两个http response header 实现；&lt;/p>
&lt;p>强缓存是浏览器现在缓存中查找是否有该资源。命中时状态码为200&lt;/p>
&lt;p>Expires:是老浏览器使用的，是一串带有固定时间的字符。他表示的是这个资源缓存的过期时间。&lt;/p>
&lt;p>它的工作原理是：&lt;/p>
&lt;p>在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的Expires的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，就把exprice和当前的时间作比较，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。&lt;/p>
&lt;p>它的缺点：因为它是和本地时间作比较的，当你的本地时间不准时它很有可能有误差。所以为了解决这个问题就有了cache control;&lt;/p>
&lt;p>cache control: 是一串数字，以秒为单位，代表的是过多久时间过期。&lt;/p>
&lt;p>它的工作原理是：&lt;/p>
&lt;p>在浏览器第一次向服务器请求资源时，服务器会给浏览器返回资源和带有response的cache control的header。服务器会把资源存在缓存中，当浏览器第二次请求时，它会在缓存中查找是否有这个资源，如果有的话，他会根据第一次请求的时间和cache control的时间计算一个资源过期时间，然后拿过期时间和当前请求的时间做对比，如果时间过了则未命中去服务器请求资源。命中则从缓存中获取资源。&lt;/p>
&lt;p>它的性能比Expires更好一点，两个可以同时启动也可以只启用一个，如果都启用的话优先cache control。&lt;/p>
&lt;p>协商缓存
协商缓存主要是利用http respense header中的ETge和Lastmodified这两组。&lt;/p>
&lt;p>协商缓存是在强缓存未命中的情况下，服务器向浏览器发送请求验证协商缓存是否命中。命中时状态码为304。&lt;/p>
&lt;p>Lastmodified:
是一串时间字符：代表的是缓存过期的时间&lt;/p>
&lt;p>浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上lastmodified，这个lastmodified表示这个资源在服务器上的最后修改时间。再次向服务端请求资源时，服务端就会返回加上If-Modified-Since的header,他表示的就是上一次请求时返回的Last-Modified的值。根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，来判断是否命中。命中就返回304状态码，同时让浏览器去缓存中拿资源。未命中则就从服务端获取资源。&lt;/p>
&lt;p>缺点:当你在浏览器端打开缓存文件时，就是你没有修改文件，浏览器也会判定你修改了资源，这样就会导致协商缓存的判断有误。为了解决这个问题，于是又有了ETag来判断协商缓存。&lt;/p>
&lt;p>ETag;
是一段特殊的字符，唯一标识的字符串。&lt;/p>
&lt;p>浏览器在第一次向服务器端请求资源时候，服务器端会向浏览器端返回资源和response的header上ETag，一段唯一辨识的字符串，再次请求时也会返回一段ETag，如果资源修改则返回的ETag是不一样的，所以通过判断两者是否相同，来判断资源是否修改，来判断是否命中缓存。&lt;/p>
&lt;p>一般浏览器两种协商缓存的方式都会存在，防止Lastmodified的不稳定。&lt;/p>
&lt;p>一般协商缓存都是配合着强缓存，如果没有强缓存，协商缓存就没有什么意义。协商缓存主要是为了帮助强缓存判断资源是否更新。&lt;/p>
&lt;p>浏览器渲染原理
&lt;a href="https://www.cnblogs.com/gwf93/p/10717281.html">https://www.cnblogs.com/gwf93/p/10717281.html&lt;/a>&lt;/p>
&lt;p>浏览器的渲染主要是5个阶段；&lt;/p>
&lt;ol>
&lt;li>浏览器读取html文件生成DOM树，他先将代码生成指令，这个过程叫做指令化，然后再指令化后，将这些指令生成node节点，这些node节点之间的关系就作为脐带，将这些节点串成一棵DOM树。&lt;/li>
&lt;/ol>
&lt;p>2.浏览器读取css文件，将css代码生成cssom。&lt;/p>
&lt;p>3.合并DOM树和cssom，生成渲染树。这个过程浏览器递归每个node节点，并给节点一个样式规则并使用。这一步需要注意，display:none并不会出现再渲染树中，它会出现在第一步的DOM树中，里面还会出现注释和script标签。&lt;/p>
&lt;p>4.渲染树布局 它会帮我们输出布置每个节点的出现的位置和大小等，就再浏览器端的位置，布置成一个一个的盒模型&lt;/p>
&lt;ol start="5">
&lt;li>渲染树绘制 它会将那些盒模型绘制上它的样式，色彩图片等等&lt;/li>
&lt;/ol>
&lt;p>考点1： 为什么操作 DOM 慢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>因为操作DOM用到了两条线程，js的引擎线程和渲染线程，js是单线程执行的，所以两天线程需要通信才能一起执行，这样会大大增加性能消耗。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>操作DOM会引起回流和重绘。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>考点2：同时加入10万条dom,如何实现不卡顿。
1.分页处理。&lt;/p>
&lt;p>2.使用requestAnimationFrame来处理，每过16.6秒循环插入dom.&lt;/p>
&lt;p>3.使用虚拟DOM,只加载可视区域的dom,加载更多的时候，用虚拟DOM去替换，https://bvaughn.github.io/react-virtualized/#/components/List&lt;/p>
&lt;p>考点3：优化，减少阻塞&lt;/p>
&lt;ol>
&lt;li>减少选择器的使用，这样能减少DOM遍历的层级，降低渲染的文件的大小&lt;/li>
&lt;/ol>
&lt;p>2.script标签会阻塞渲染进程，所以我们的script代码应该写在html文件的下面。&lt;/p>
&lt;p>3.没有任何依赖的js文件我们可以加上asyac属性，这样就不会影响渲染的进度。&lt;/p>
&lt;p>考点4：重绘和回流
重绘不改变布局，只改变一些颜色什么的&lt;/p>
&lt;p>回流会改变布局。&lt;/p>
&lt;p>回流一定会引发重绘。&lt;/p>
&lt;p>浏览器的存储
&lt;a href="https://juejin.im/post/6844903812092674061#heading-2">https://juejin.im/post/6844903812092674061#heading-2&lt;/a>&lt;/p>
&lt;p>Cookie,LocalStorage,sessionStorage,IndexedDB
Cookie
浏览器是无状态的，他无法记住浏览器上一步做的是什么，所以很多功能无法实现，比如购物车，所以浏览器创建cookie来使用，用于保存用户的状态，在购物东西时cookie就好像一辆购物车，用来保存用户选购的商品信息，它在浏览器和服务器之间来回传输信息。&lt;/p>
&lt;p>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储。通过保存用户的信息，来保存登录状态，登录还刷新还能回到原来的状态。可以保存一段时间。&lt;/p>
&lt;p>缺点：内存较小一般就几k大小，所以只能保存用户信息不能保存大文件内容。&lt;/p>
&lt;p>cookie过多可能会带来过的性能消耗。&lt;/p>
&lt;p>cookie还存在一定的安全性。&lt;/p>
&lt;p>LocalStorage
内存较大有5M左右，除非被清除否则永久保存，接口容易封装，仅在浏览器中保存，不参与通信&lt;/p>
&lt;p>sessionStorage
内存较大有5M左右，关闭页面就消失，接口容易封装，仅在浏览器中保存，不参与通信&lt;/p>
&lt;p>IndexedDB
内存无线，永久保存。&lt;/p>
&lt;p>跨域
数据的请求都要遵循同源策略，既需要同域名，同端口，同协议。所以违反了这个规则则就算跨域了。&lt;/p>
&lt;p>解决跨域的四个方法：&lt;/p>
&lt;p>From表单能够帮我们跨域请求信息。疯狂发送请求&lt;/p>
&lt;p>jsonp 利用&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->的没有跨域限制请求&lt;/p>
&lt;p>cors 后端设置允许跨域，或者搞个白名单，允许那些能跨域请求&lt;/p>
&lt;p>nginx 代理
最后：
有时间再整理跨域和存储。&lt;/p></description></item></channel></rss>